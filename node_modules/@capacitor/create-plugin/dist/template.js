"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.packageNameToNative = exports.applyTemplate = exports.extractTemplate = exports.readPackageJson = exports.CAPACITOR_VERSION = void 0;
const tslib_1 = require("tslib");
const promises_1 = require("fs/promises");
const mustache_1 = tslib_1.__importDefault(require("mustache"));
const path_1 = require("path");
const tar_1 = tslib_1.__importDefault(require("tar"));
const MUSTACHE_EXTENSION = '.mustache';
exports.CAPACITOR_VERSION = '^6.0.0';
const TEMPLATE_PATH = (0, path_1.resolve)(__dirname, '..', 'assets', 'plugin-template.tar.gz');
const WWW_TEMPLATE_PATH = (0, path_1.resolve)(__dirname, '..', 'assets', 'www-template.tar.gz');
const readPackageJson = async (p) => {
    const contents = await (0, promises_1.readFile)(p, { encoding: 'utf8' });
    return JSON.parse(contents);
};
exports.readPackageJson = readPackageJson;
const extractTemplate = async (dir, details, type) => {
    const templateFiles = [];
    const templateFolders = [];
    await (0, promises_1.mkdir)(dir, { recursive: true });
    await tar_1.default.extract({
        file: type === 'PLUGIN_TEMPLATE' ? TEMPLATE_PATH : WWW_TEMPLATE_PATH,
        cwd: dir,
        filter: (p) => {
            if (p.endsWith(MUSTACHE_EXTENSION)) {
                templateFiles.push(p);
            }
            if (p.endsWith('__CLASS__Plugin/') || p.endsWith('__CLASS__PluginTests/')) {
                templateFolders.push(p);
            }
            return true;
        },
    });
    await Promise.all(templateFiles.map((p) => (0, path_1.resolve)(dir, p)).map((p) => (0, exports.applyTemplate)(p, details)));
    await Promise.all(templateFolders.map((p) => (0, path_1.resolve)(dir, p)).map((p) => (0, promises_1.rmdir)(p)));
};
exports.extractTemplate = extractTemplate;
const applyTemplate = async (p, { name, 'package-id': packageId, 'class-name': className, repo, author, license, description }) => {
    const template = await (0, promises_1.readFile)(p, { encoding: 'utf8' });
    const view = {
        CAPACITOR_VERSION: exports.CAPACITOR_VERSION,
        PACKAGE_NAME: name,
        PACKAGE_ID: packageId,
        NATIVE_NAME: packageNameToNative(name),
        CLASS: className,
        JAVA_PATH: (0, path_1.join)(packageId.split('.').join(path_1.sep), className),
        REPO_URL: repo ? repo.replace(/\/$/, '') : '',
        AUTHOR: author,
        LICENSE: license,
        DESCRIPTION: description,
    };
    const contents = mustache_1.default.render(template, view);
    const filePath = Object.entries(view).reduce((acc, [key, value]) => (value ? acc.replaceAll(`__${key}__`, value) : acc), p.substring(0, p.length - MUSTACHE_EXTENSION.length));
    await (0, promises_1.mkdir)((0, path_1.dirname)(filePath), { recursive: true });
    // take off the .mustache extension and write the file, then remove the template
    await (0, promises_1.writeFile)(filePath, contents, { encoding: 'utf8' });
    await (0, promises_1.unlink)(p);
};
exports.applyTemplate = applyTemplate;
function packageNameToNative(name) {
    name = name
        .replace(/\//g, '_')
        .replace(/-/g, '_')
        .replace(/@/g, '')
        .replace(/_\w/g, (m) => m[1].toUpperCase());
    return name.charAt(0).toUpperCase() + name.slice(1);
}
exports.packageNameToNative = packageNameToNative;
